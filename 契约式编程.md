## 契约式编程

### 契约的意义

在人类的社会活动中，契约一般是用于两方，一方（供应者）为另一方（客户）完成一些任务。每一方都期待从契约中获得利益，同时也要接受一些义务。通常，一方视为义务的对另一方来说是权利。契约文档要清楚地写明双方的权利与义务。

契约合同能保障双方的利益，对客户来说，合同规定了供应者要做的工作；对供应者来说，合同说明了如果约定的条件不满足，供应者没有义务一定要完成规定的任务。

同样的道理也适合于软件。设想一个软件单元E。它要达到它的目的（履行契约）， E使用的策略可能会包括一系列的子任务，t1, ... tn。如果子任务ti 不是那么简单的，它得调用另一个功能例程（routine)R。换句话说，E把子任务转包给R。这样的情形应该被一个很好定义的“登记表”(roster）来管理双方的义务与权利－－契约。

### 契约编程关注的重点

**先验条件：对于函数来讲，期望所有调用它的模块都保证一定的进入条件，这样它就不用去处理不满足先验条件的情况，先验条件发生在每个函数的最开始。**

例如在我们的addRelation方法中：

这样的先验条件保证了不同情况的执行。

```java
/*@ public normal_behavior
  @ requires contains(id1) && contains(id2) && !getPerson(id1).isLinked(getPerson(id2))
  @ also
  @ public exceptional_behavior
  @ requires !contains(id1) || !contains(id2) || getPerson(id1).isLinked(getPerson(id2));*/
```

**后验条件：保证退出时给出特定的属性，也就是说函数保证能做到的事情，函数完成时的状态，函数有这一事实表示它会结束，不会无休止的循环，后验条件发生在每个函数的最后。**

在我们的方法中，就有这样的语句，保证执行后的结果，我们在写代码的时候，对于函数的处理过程，就是从这一部分了解到的。

```java
/*@ ensures getPerson(id1).value.length ==
		getPerson(id1).acquaintance.length;
  @ ensures getPerson(id2).value.length == 
		getPerson(id2).acquaintance.length;
  @ ensures \old(getPerson(id1).value.length) == 
		getPerson(id1).acquaintance.length - 1;
  @ ensures \old(getPerson(id2).value.length) == 
		getPerson(id2).acquaintance.length - 1; */
```

**不变式：在进入时假定，并在退出时保持一些特定的属性，不变式实际上是前置条件和后置条件的交集，违反这些操作会导致程序抛出异常。从调用者的角度来看，该条件总是为真，在函数的内部处理过程中，不变项可以为变，但在函数结束后，控制返回调用者时，不变项必须为真。**

同样在此类中，我们可以看到如下的语句，保证了方法执行后，people中的不同对象，均能与执行前对应（相等）。

```java

/*@ ensures (\forall int i; 0 <= i && i < \old(people.length);
  @          (\exists int j; 0 <= j && j < people.length; 
  		people[j] == \old(people[i]))); */
```

### 契约式编程的原则

**（1）区分命令和查询。查询返回一个结果，但不改变对象的可见性质。命令改变对象的状态，但不一定返回结果。**

这一点在我们面向对象的学习中已经数见不鲜，我们的get & set方法就是最好的例子。

**（2）将基本查询同派生查询分开。派生查询可以用基本查询来定义。**

在这里我的想法是：派生查询比较简单的例子，其中，包括了我们基本查询的使用，并且和（3）一样，我们的结果用了多个基本查询的结果来定义。

```java
public /*@ pure @*/ boolean isCircle(int id1, int id2) throws PersonIdNotFoundException {
    if (contains(id1) && contains(id2)) {
        return find(getPerson(id1)).equals(find(getPerson(id2)));
    }
    else if (!contains(id1)) {
        throw new MyPersonIdNotFoundException(id1);
    }
    else {
        throw new MyPersonIdNotFoundException(id2);
    }
}
```

**（3） 针对每个派生查询，设定一个后验条件，使用一个或多个基本查询的结果来定义它。这样我们只要知道基本查询的值，也就能知道派生查询的值。**

**（4） 对于每个命令都撰写一个后验条件，规定每个基本查询的值。结合“用基本查询定义派生查询”的原则，我们已经能够知道每个命令的全部可视效果。**

此处还可以用addRelation方法的例子，我们保证执行后的结果就用到了多个基本查询的值。

```java
/*
@ ensures getPerson(id1).value.length == getPerson(id1).acquaintance.length;
@ ensures getPerson(id2).value.length == getPerson(id2).acquaintance.length;
@ ensures \old(getPerson(id1).value.length) == getPerson(id1).acquaintance.length - 1;
@ ensures \old(getPerson(id2).value.length) == getPerson(id2).acquaintance.length - 1;
*/
```

**（5）对于每个查询和命令，采用一个合适的先验条件。先验条件限定了客户调用查询和命令的时机。**

不再赘述，和前面一样

**（6） 撰写不变式来定义对象的恒定特性。类是某种抽象的体现，应当将注意力集中在最重要的属性上，以帮助读者建立关于类抽象的正确概念模型。**

### 契约式编程与接口

接口在声明类必须遵循的规则时非常有用。契约式编程技术使用这一功能来增强封装性，优化工作流。

### 防御式编程——是否是契约式编程无限增加考虑先验条件的结果呢？

![](C:\Users\韩振涛\Desktop\契约式编程.assets\625ba863e6f7a3b77ddfbf0aaa292a3f.png)

### 防御式编程常见的技术

**断言**

断言是用在开发和维护阶段的，生产环境又被去除，以免降低系统的性能。我认为和我们的契约式编程很相似。

例如：

```java
private  int volume(int length, int width, int height) {
    //前置条件
    assert length>0 && length<=100 :"长度必须大于0且小于等于100";
    assert width>0 && width<=100:"宽度必须大于0且小于等于100";
    assert height>0 && height<=100:"高度必须大于0且小于等于100";
    int volume = length*width*height;
    //后置条件
    assert volume>0 && volume<=1000000:"体积必须大于0且小于等于1000000";
    return volume;
}
```

如果数据来源于可信的系统内部，使用断言非常合适。

**错误处理**

![07e58b797bcb93704cd71bb310c8c03b](C:\Users\韩振涛\Desktop\契约式编程.assets\07e58b797bcb93704cd71bb310c8c03b.png)



返回中立值：继续执行操作并简单地返回一个没有危害的数值
		数值计算可以返回0
		字符串操作可以返回空字符串
		指针操作可以返回一个空指针
换用下一个正确的数据：在处理数据流的时候，返回下一个正确的数据即可
返回与上一次相同的数据
		“重用上一次正确的结果”
		如windows系统崩溃后用上一次配置重启动
换用最接近的合法值
		常出现在数值超出其正常设定的上下界的时候
		Velocity的例子
把警告信息记录到日志文件中
		在使用这种方法的时候需要对错误信息进行标示，或者将警告信息单独存放，以便快速查询定位
		可以和其他技术结合使用
返回一个错误码：当只有系统的某些部分处理错误，而其他部分则不在本地(局部)处理错误时
		设置一个状态变量的值
		用状态值作为函数的返回值
		用语言内建的异常机制抛出一个异常
调用错误处理子程序或对象
		把错误处理集中在一个全局的错误处理子程序或对象
		优点：能把错误处理的职责都集中到一起
		代价：错误处理代码与整个程序紧密耦合
显示出错消息
		当心：不要告诉系统的潜在攻击者太多东西
		“程序应该只在没有什么可做的情况下才向用户报告错误”
用最妥当的方法在局部处理错误
		具体采用何种错误处理方法由具体程序员决定
		灵活度高，但系统的整体性能将无法满足对其正确性或可靠性的需求
关闭程序：适用于人身安全攸关的应用程序



**异常**

在我们的作业中，这样的异常处理非常常见

```java
/*@ public exceptional_behavior
@ assignable \nothing;
@ requires !contains(id1) || !contains(id2) || getPerson(id1).isLinked(getPerson(id2));
@ signals (PersonIdNotFoundException e) !contains(id1);
@ signals (PersonIdNotFoundException e) contains(id1) && !contains(id2);
@ signals (EqualRelationException e) contains(id1) && contains(id2) &&
@         getPerson(id1).isLinked(getPerson(id2));
@*/
```

抛出的异常也是程序接口的一部分，代码应抛回一个与其所在类的接口相一致的异常，并且在异常消息中加入关于导致异常发生的全部信息：确保消息中含有为理解异常抛出原因所需的信息，如数组下标错误。

这一点在我们练习中有很好的体现，同时保证了与接口的类型一致，并且在抛出时也得到了异常出现的id信息。

### 个人对这两种编程思想的看法




















PPT 1

大家好，今天的研讨会上，我选择的主题是从我们第四次作业中看到的契约式，防御式编程思想。

PPT 2

我的报告分为以下几部分：

PPT 3

PPT 4 

首先，我们先来看一下什么是契约式编程：契约式编程像是一种约定，比如在我们大一c语言的学习中，有这样的一些约定，对于我们的代码来说，这些约定可以在不同角度上提高我们代码的质量。

PPT 5 

契约式编程要求我们在「**前置条件**」、「**后置条件**」和「**不变量条件**」进行契约的检查。类似的，例如检查参数，一旦参数不对，当即撕毁契约。

契约所约束的，是「**一个为了确保程序正常运行的条件**」，一旦契约被损毁，只有一个原因，那就是程序出了 Bug。

例如，一个参数，在我处理的时候，必须保证是不为空的。那么谁来保证这一点呢？一定是我的调用方（或者说是其它模块），所以，一旦出现问题，应该由调用方来检查，确保调用的时候，必须是不为空的。

PPT 6

那么，我们所关注的，契约式编程的重点和规则是怎样体现的呢？

PPT 7

例如在我们的addRelation方法中，我展示的是我们课程组提供的部分jml的拼接版。我们的规格总会在开始之前为我们提供这个方法运行的前置条件，在此方法中，我们要求id12均能够找到，并且有联系，这就是我们所需要的前置条件。

结合其它的jml规格来看，我们几乎所有方法规格都会有对于方法运行情况的限制。

PPT 8

接下来就是我们关注的另一个重点后置条件。

后置条件保证了方法退出时给出特定的属性

在我们的方法中，就有这样的语句，保证执行后的结果，从我个人的感受来看，我们在写代码的时候，对于函数的处理结果，就是从这一部分了解到的。这一部分所对应的，也就是我们方法运行后，保证结果满足我们的需要。

PPT 9

契约式编程关注的最后一个重点是不变式，这个在我们的作业中也有很多的体现，不变式保证了我们的方法对于一些重要的内容不会作出改动。明白了这三点，我们也就能大致知道jml规格的每一部分的必要性。

接下来是契约式编程的几个原则，首先是区分命令与查询

PPT 10

这一点在我们面向对象的学习中已经数见不鲜，我们的get & set方法就是最好的例子。

对于这一点我的思考是：函数有副作用。有时候，他们会改变系统的状态，特别是当你最不希望这么做时，从而造成各种各样的意想不到的破坏。在我们面向对象的编程范式中很难去除所有的副作用。我们需要确保可变状态得到明确管理，才能保证在我们没有注意到时不会被状态拖累。

看看下面的代码，它是命令还是查询？显然，第二个改变了系统的状态，但是第一个没有。

所以这样的做法很好的管理了我们代码潜在的副作用。

PPT 11

这是一个派生查询比较简单的代码例子，其中，包括了我们基本查询的使用，并且如果你去看我们的jml规格，能发现jml的书写方式和（3）一样，我们的结果用了多个基本查询的结果来定义。

PPT 12

此处还可以用addRelation方法的例子，我们保证执行后的结果就用到了多个基本查询的值。并且这样的后置条件一般是查询方法所没有的。

PPT 13

第五六点和之前的关注点重复，我就不再赘述

PPT 14

PPT 15

首先请大家看这张图，这一张图是我们在对自己的项目做开发时的经典流程，比如我们的课下作业如果去主动测试发现问题，那么可能就会在强测互测中出现各种各样的bug，那么这跟我想说的防御式编程有什么关系呢？我们所作的自主测试，其实也就是一种防御式编程，不过因为课程组对于我们的数据有所限制，我们是从正确性的角度，去防御其它互测成员的hack，从项目角度来说，可能我们的侧重点就转移到了程序的正常运行上，用户的输入是不可预知的，如果不加以测试不同情况的数据输入，可能不仅仅是程序运行错误，而是程序的崩溃。

PPT 16

所以说这就是防御式编程的核心思想，

防御性编程并不意味着要对自己的程序提高警惕，这一想法是在防错性驾驶的基础上产生的，在这种驾驶方法中，必须在心中时刻认为为其它驾驶员的行为都是不可预测的。这样， 就可以在他们做出某些危险举动时，确保自己不会因此受伤。在防御式编程中，其中心思想是， 即使一个子程序被传入了坏数据，它也不会被伤害，哪怕这个数据是由其它子程序错误而产生的。更一般地说，其思想核心是要承认程序中都会有问题，都要被改动。

在架构的设计上，我们要一般考虑到这样的几点：**检查所有来源于外部的数据的值**，当从⽂件、⽤户、⽹络或其他外部接⼝中获取数据时，应检查所获得的数据值，以确保它在允许的范围内

**检查子程序的所有输入参数的值**事实上和检查来源于外部的数据⼀样，只不过数据来源于其他⼦程序⽽⾮外部接⼝。

**决定如何处理错误的输入数据。**⼀旦检测到⾮法的参数，你该如何处理它呢？根据情况的不同，你可以选择适合你的技术来处理。那么防御型编程的技术有哪些呢？

PPT 17

PPT 18

断言（assertions）。

断言是指一段放在代码中，当代码运行时可以使其自检的可执行语句。

/*

如果断言显示出正确信息，那么表明一切都正常运行。 如果显示出错误信息，那么表明它在程序中发现了错误。比如，系统假定用户信息文件永远不会超过 5000 记录行，那么程序中可能会包含一段说明这个假定的断言。只要这个文件不超过 5000，那么断言就保持沉默，而一旦断言发现此文件超过了 5000 个记录行，那它就会声称已发 现了一个错误。 为了在程序中加入断言，你必须知道在设计系统时所做的假设，这也是在结构设计中应阐明采用假设的原因之一

*/

这一点老师上课的时候已经提及过，同时，如果我们是在开发商用软件中，那么我们应该避免断言信息混在程序中。

在开发阶段， 可以设置包含全部调试辅助手段的版本控制工具，这样，到了产品阶段，就可以很容易地去掉在商用版本中所不希望出现的这些辅助手段。 

使用内部预处理，如果在编程环境中带有预处理程序，如 C 语言，那么仅用一下编译程序开关，就可以加入或去掉这些辅助手段。

PPT 19

错误处理已成为当代计算机科学中最棘手的问题，没有谁能担负起频繁应付它的负担。有 人估计，程序中有 90％的代码是为了应付例外的错误处理或者内务处理而编写的，就是说仅有 10％的代码才是处理正常情况的。下图就是对于不同的错误情况所作的可能的处理结构

PPT 20

接下来是对于程序的错误处理

错误处理是纠正还是仅仅测试错误？

如果是纠正错误，程序可以尝试从错误状态下恢复。

如果仅仅是测试，那么程序可以继续运行，就像什么也没有发生一样，或者直接退出运行。但无论在哪种情况下，都应该提醒用户发现了错误。 

错误测试是主动的还是被动的？

系统可以积极地预防错误，如通过检验用户的输入是 否合法，

当然也可以消极地在无法回避它们时才做出反应。例如，用户的一系列输入 产生了溢出，你可以清除，也可以滤除信息。同样，无论哪种方案，都要提醒用户。 

程序是怎样对付错误的？

一旦测试出错误，程序可以立刻抛弃产生错误的数据，

也可以把它当作错误而进入错误处理状态，

还可以等到全部处理完毕后再通知用户数据有 误。

处理错误信息的约定是什么呢？如果结构设计中没有规定某种策略。那么用户界面在程序的不同部分就会像迷宫中的通道一样忽东忽西，让人摸不着头脑。为避免出现这 类问题，结构设计中应建立一套处理错误信息的约定。 

在程序中，应该在哪一个层次上处理错误呢？

你可以在发现的地方立即处理，也可以 把它交给一个错误处理子程序去处理，或者交给更高层次的子程序处理。 

PPT 21

列举常见的处理方式。

PPT 22

这一点在我们的课程中有很丰富的体现。

